<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (jpx_codestream_target::set_breakpoint) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="jpx$arget__cop$ttributes.html"> prev </A>||<A HREF="jpx$arget__acc$ment_list.html"> next </A>|</P>
<H1><A NAME="ToP">jpx_codestream_target::set_breakpoint</A></H1>
<P CLASS="function-text"><B>void</B> set_breakpoint(
<B>int</B>&nbsp;i_param,
<B>void</B>&nbsp;*&nbsp;addr_param)</P>
<P>[Declared in <A HREF="++++apps+c$essed_io+jpx+h.html">"../apps/compressed_io/jpx.h"</A>]</P><P><A HREF="jpx$arget.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
If you wish to record any specific boxes within the
codestream header (chdr) box for this codestream, over
and above the Image Header (ihdr), Bits Per Component
(bpcc), Palette (pclr) and Component Mapping (cmap)
boxes which are automatically generated, you should
install a breakpoint. Doing this will ensure firstly
that a Codestream Header box is always written (even
if all the other boxes are already recorded in the
JP2 header box). Secondly, the relevant call to 
<A HREF="jpx_target__wri$_headers.html">jpx_target::write_headers</A> will return prematurely, providing you with an opportunity
to write the additional boxes, after which 
<A HREF="jpx_target__wri$_headers.html">jpx_target::write_headers</A> must be called again to resume the header generation
process.
</P><P>
 You should note that it is possible that the installed
breakpoint will be encountered during a call to 
<A HREF="jpx_target__wri$metadata.html">jpx_target::write_metadata</A>, instead of 
<A HREF="jpx_target__wri$_headers.html">jpx_target::write_headers</A>, due to constraints that might be set up by adding
number list metanodes in a way that requires them to
be embedded in JPX containers. See 
<A HREF="jpx$anode__add_numlist.html">jpx_metanode::add_numlist</A>, 
<A HREF="jpx$nager__insert_node.html">jpx_meta_manager::insert_node</A> and 
<A HREF="jpx_target__wri$metadata.html">jpx_target::write_metadata</A> for more on this.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="i_param">i_param</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
This is an arbitrary integer identifier which will
be returned by 
<A HREF="jpx_target__wri$_headers.html">jpx_target::write_headers</A> or 
<A HREF="jpx_target__wri$metadata.html">jpx_target::write_metadata</A>. You might use this to provide an interpretation for
the 
<A HREF="jpx$arget__set$reakpoint.html#addr_param">addr_param</A> value, allowing you to reliably cast it to some appropriate
object reference. Alternatively, you might use either
or neither of the two parameters, relying perhaps on
the box type of the 
<A HREF="jp2$1t_box.html">jp2_output_box</A> returned by 
<A HREF="jpx_target__wri$_headers.html">jpx_target::write_headers</A> or 
<A HREF="jpx_target__wri$metadata.html">jpx_target::write_metadata</A>.
</P>
</DIV>
<H4><A NAME="addr_param">addr_param</A> [<B>void</B>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
This is an arbitrary address which will be returned
by 
<A HREF="jpx_target__wri$_headers.html">jpx_target::write_headers</A> or 
<A HREF="jpx_target__wri$metadata.html">jpx_target::write_metadata</A>.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="jpx$arget__cop$ttributes.html"> prev </A>||<A HREF="jpx$arget__acc$ment_list.html"> next </A>|</P>
</BODY>
</HTML>
