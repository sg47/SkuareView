<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_stripe_decompressor::pull_stripe) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$2essor__pull_stripe__6.html"> prev </A>||<A HREF="kdu$2essor__pull_stripe__8.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_stripe_decompressor::pull_stripe</A></H1>
<P>Overload navigation: <B><A HREF="kdu$2essor__pull_stripe__1.html">1</A>,
<A HREF="kdu$2essor__pull_stripe__2.html">2</A>,
<A HREF="kdu$2essor__pull_stripe__3.html">3</A>,
<A HREF="kdu$2essor__pull_stripe__4.html">4</A>,
<A HREF="kdu$2essor__pull_stripe__5.html">5</A>,
<A HREF="kdu$2essor__pull_stripe__6.html">6</A>,
7,
<A HREF="kdu$2essor__pull_stripe__8.html">8</A></B></P>
<P CLASS="function-text"><B>bool</B> pull_stripe(
<B>float</B>&nbsp;*&nbsp;stripe_bufs[],
<B>int</B>&nbsp;stripe_heights[],
<B>int</B>&nbsp;*&nbsp;sample_gaps=NULL,
<B>int</B>&nbsp;*&nbsp;row_gaps=NULL,
<B>int</B>&nbsp;*&nbsp;precisions=NULL,
<B>bool</B>&nbsp;*&nbsp;is_signed=NULL)</P>
<P>[Declared in <A HREF="++++apps+s$decompressor+h.html">"../apps/support/kdu_stripe_decompressor.h"</A>]</P><P><A HREF="kdu$2essor.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
Same as the first form of the overloaded 
<A HREF="kdu$2essor__pull_stripe__1.html">pull_stripe</A> function, except that stripe samples for each image
component are provided with a floating point representation.
In this case, the interpretation of the 
<A HREF="kdu$2essor__pull_stripe__7.html#precisions">precisions</A> member is slightly different, as explained below.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ReturnS">Return Value</A></H2><DIV CLASS="indented-text">
<P>
True until all samples of all image components have
been decompressed and returned, at which point the
function returns false.
</P>
</DIV>
<H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="stripe_bufs">stripe_bufs[]</A> [<B>float</B>&nbsp;*]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="stripe_heights">stripe_heights[]</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
See description of the first form of the 
<A HREF="kdu$2essor__pull_stripe__1.html">pull_stripe</A> function.
</P>
</DIV>
<H4><A NAME="sample_gaps">sample_gaps</A> [<B>int</B>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
See description of the first form of the 
<A HREF="kdu$2essor__pull_stripe__1.html">pull_stripe</A> function.
</P>
</DIV>
<H4><A NAME="row_gaps">row_gaps</A> [<B>int</B>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
See description of the first form of the 
<A HREF="kdu$2essor__pull_stripe__1.html">pull_stripe</A> function.
</P>
</DIV>
<H4><A NAME="precisions">precisions</A> [<B>int</B>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
If NULL, all component samples are deemed to have a
nominal range of 1.0; that is, signed values lie in
the range -0.5 to +0.5, while unsigned values lie in
the range 0.0 to 1.0; equivalently, the precision is
taken to be P=0. Otherwise, the argument points to
an array with one precision value for each component.
The precision value, P, identifies the nominal range
of the samples which are produced, such that signed
values range from -2^{P-1} to +2^{P-1}, while unsigned
values range from 0 to 2^P.
</P><P>
 The value of P, provided by the 
<A HREF="kdu$2essor__pull_stripe__7.html#precisions">precisions</A> argument may be the same, larger or smaller than the
actual bit-depth, B, of the corresponding image component,
as provided by the 
<A HREF="globals.html#Sprecision">Sprecision</A> attribute (or the 
<A HREF="globals.html#Mprecision">Mprecision</A> attribute) managed by the 
<A HREF="siz_params.html">siz_params</A> object passed to 
<A HREF="kdu$tream__create__1.html">kdu_codestream::create</A>. The relationship between samples represented at bit-depth
B and the floating point quantities generated by this
function is that the latter are understood to have
been scaled by the value 2^{P-B}.
</P><P>
 While this scaling factor seems quite natural, you
should pay particular attention to its implications
for small values of B. For example, when P=1 and B=1,
the nominal range of unsigned floating point quantities
is from 0 to 2, while the actual range of 1-bit sample
values is obviously from 0 to 1. Thus, the maximum
"white" value actually occurs when the floating point
quantity equals 1.0 (half its nominal maximum value).
For signed floating point representations, the implications
are even less intuitive, with the maximum integer value
achieved when the floating point sample value is 0.0.
More generally, although the nominal range of the floating
point component sample values is of size 2^P, a small
upper fraction &mdash; 2^{-B} &mdash; of this nominal
range lies beyond the range which can be represented
by B-bit samples.
</P><P>
 There is no guarantee that returned component samples
will lie entirely within the range dictated by the
corresponding B-bit integers, or even within the nominal
range. This is because the function does not perform
any clipping of out-of-range values, and the impact
of quantization effects in the subband domain is hard
to quantify precisely in the image domain.
</P><P>
 It is worth noting that this function, unlike its
predecessors, allows P to take both negative and positive
values. For implementation reasons, though, we restrict
precisions to take values in the range -64 to +64.
</P>
</DIV>
<H4><A NAME="is_signed">is_signed</A> [<B>bool</B>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
If NULL, the samples returned for each component, c,
will have a signed representation, with a nominal range
from -2^{
<A HREF="kdu$2essor__pull_stripe__7.html#precisions">precisions</A>[c]-1} to +2^{
<A HREF="kdu$2essor__pull_stripe__7.html#precisions">precisions</A>[c]-1}. Otherwise, this argument points to an array
with one element for each component. If 
<A HREF="kdu$2essor__pull_stripe__7.html#is_signed">is_signed</A>[c] is true, the default signed representation is adopted
for that component; if false, the component samples
are assigned an unsigned representation, with a nominal
range from 0.0 to 2^{
<A HREF="kdu$2essor__pull_stripe__7.html#precisions">precisions</A>[c]}. What this means is that the function adds 2^{
<B>precisions[c]</B>-1} to the samples of any component for which 
<A HREF="kdu$2essor__pull_stripe__7.html#is_signed">is_signed</A>[c] is false, before returning them &mdash; if 
<A HREF="kdu$2essor__pull_stripe__7.html#precisions">precisions</A> is NULL, 0.5 is added.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$2essor__pull_stripe__6.html"> prev </A>||<A HREF="kdu$2essor__pull_stripe__8.html"> next </A>|</P>
</BODY>
</HTML>
