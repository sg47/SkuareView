<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_window_model) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#FFF491">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#FuncS"> functions </A>|</P>
<H1><A NAME="ToP">kdu_window_model</A></H1>
<DIR><DIR><H3><U>Java:</U> class Kdu_window_model</H3></DIR></DIR>

<P>[Declared in <A HREF="++++apps+c$lient_window+h.html">"../apps/compressed_io/kdu_client_window.h"</A>]</P><P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
This object is used to manage cache model manipulation
instructions, as passed to 
<A HREF="kdu_serve__set_window.html">kdu_serve::set_window</A>. The object supports all possible cache model instructions
that can be expressed within the JPIP standard (IS15444-9),
while also allowing the server to defer its processing
of those instructions in such a way as to minimize
resource consumption.
</P><P>
 JPIP allows for cache model instructions which can
be unbounded in scope (e.g., large or even open ranges
of codestreams, tiles, components, etc.); however,
this type of instruction can be used only with stateless
requests, which means that the instructions need only
be applied to the content which is actually going to
be served. More generally, Kakadu's server implementation
defers processing of all cache model instructions until
the point where the relevant content is about to be
served. This allows late instantiation of the resources
required to properly interpret the cache model instructions
and also ensures that all possible styles of cache
modeling instruction can be handled (and handled efficiently).
At the time of this writing, we are not aware of any
other vendor who can handle the full range of instructions
permitted by the standard.
</P><P>
 For session-based requests, it is possible that some
cache model instructions refer to content which is
not actually associated with an imagery request. However,
these instructions are necessarily atomic (one codestream,
one tile, one component, one resolution, one precinct).
As the server visits content of interest to serve to
the client, it processes atomic and non-atomic cache
model instructions which are relevant to the content.
The present object automatically discards atomic instructions
as they are accessed, so that once all content relevant
to a window of interest has been visited, the server
can complete any session-based cache modeling obligations
simply by accessing and processing any residual atomic
instructions (in most cases, there should be none).
</P><P>
 In view of the above, the present object provides
two ways to access cache model instructions: instructions
which retrieve and discard a single atomic instruction;
and functions which apply atomic and non-atomic instructions
to a set of data-bins which are of interest to the
caller, discarding the atomic ones. With this introduction,
it should be possible to understand the function interfaces
provided below.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="FuncS">Public Functions</A></H2><DIV CLASS="indented-text">
<P><A HREF="kdu$model__kdu$dow_model__1.html">kdu_window_model</A> <EM>(2 forms)</EM> {<U>Java:</U> Kdu_window_model}
</P>
<P><A HREF="kdu$model__~kd$dow_model.html">~kdu_window_model</A> {<U>Java:</U> Native_destroy}
</P>
<P><A HREF="kdu$model__operator=.html">operator=</A></P>
<P><A HREF="kdu$model__copy_from.html">copy_from</A> {<U>Java:</U> Copy_from}
</P>
<P><A HREF="kdu$model__clear.html">clear</A> {<U>Java:</U> Clear}
</P>
<P><A HREF="kdu$model__init__1.html">init</A> <EM>(2 forms)</EM> {<U>Java:</U> Init}
</P>
<P><A HREF="kdu$model__is_stateless.html">is_stateless</A> {<U>Java:</U> Is_stateless}
</P>
<P><A HREF="kdu$model__is_empty.html">is_empty</A> {<U>Java:</U> Is_empty}
</P>
<P><A HREF="kdu$model__append.html">append</A> {<U>Java:</U> Append}
</P>
<P><A HREF="kdu$model__set$m_context.html">set_codestream_context</A> {<U>Java:</U> Set_codestream_context}
</P>
<P><A HREF="kdu$model__add$struction__1.html">add_instruction</A> <EM>(2 forms)</EM> {<U>Java:</U> Add_instruction}
</P>
<P><A HREF="kdu$model__get$tructions.html">get_meta_instructions</A> {<U>Java:</U> Get_meta_instructions}
</P>
<P><A HREF="kdu$model__get$ic_stream.html">get_first_atomic_stream</A> {<U>Java:</U> Get_first_atomic_stream}
</P>
<P><A HREF="kdu$model__get$tructions__1.html">get_header_instructions</A> <EM>(2 forms)</EM> {<U>Java:</U> Get_header_instructions}
</P>
<P><A HREF="kdu$model__get$1tructions.html">get_precinct_instructions</A> {<U>Java:</U> Get_precinct_instructions}
</P>
<P><A HREF="kdu$model__get$nct_block.html">get_precinct_block</A> {<U>Java:</U> Get_precinct_block}
</P>
</DIV>
<P ALIGN="CENTER"><HR></P>
<P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#FuncS"> functions </A>|</P>
</BODY>
</HTML>
