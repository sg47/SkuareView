<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_serve::generate_increments) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu_serve__ret$ta_chunks.html"> prev </A>||<A HREF="kdu_serve__win$_finished.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_serve::generate_increments</A></H1>
<P CLASS="function-text"><A HREF ="kds_chunk.html">kds_chunk</A>&nbsp;* generate_increments(
<B>int</B>&nbsp;suggested_message_bytes,
<B>int</B>&nbsp;&amp;&nbsp;max_message_bytes,
<B>bool</B>&nbsp;align=false,
<B>bool</B>&nbsp;use_extended_message_headers=false,
<B>bool</B>&nbsp;decouple_chunks=false,
<B>int</B>&nbsp;context_id=0,
<B>int</B>&nbsp;suggested_chunk_size=0)</P>
<P>[Declared in <A HREF="++++apps+k$er+kdu_serve+h.html">"../apps/kdu_server/kdu_serve.h"</A>]</P><P><A HREF="kdu_serve.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
This function returns a linked list of 
<A HREF="kds_chunk.html">kds_chunk</A> objects, representing new elements of the JPEG2000
compressed imagery or metadata which is relevant to
the window most recently passed to 
<A HREF="kdu_serve__set_window.html">set_window</A>. The chunks contain one or more whole JPIP messages,
each of which represents a byte range from one such
element. Possible elements are metadata-bins, precinct
data-bins, code-stream main header data-bins and tile
header data-bins. The object does not currently support
delivery of tile data-bins, which offer substantially
less flexibility. It is possible that some messages
which have previously been generated by this function
will overlap with the new messages, resulting in redundant
transmission by the server application. This may happen
if the 
<B>truncate_cache_model</B> function is used to clear the server's memory of information
it may previously have generated.
</P><P>
 Server applications typically call this function repeatedly,
indicating the total number of message bytes which
they would like to be contained in the returned chunks.
As of Kakadu v6.2, the 
<A HREF="kdu_serve__gen$ncrements.html#suggested_message_bytes">suggested_message_bytes</A> limit includes the length of message headers as well
as message body data contained in the returned list
of 
<A HREF="kds_chunk.html">kds_chunk</A> objects. Messages and their headers are described
by the JPIP standard (currently committee draft, but
will become IS 15444-9).
</P><P>
 Applications will ideally select 
<A HREF="kdu_serve__gen$ncrements.html#suggested_message_bytes">suggested_message_bytes</A> on the basis of their current estimates regarding
the communication bandwidth. If the application attempts
to transfer too much data from the current window to
a remote client, the client's window of interest may
change before the data can be transmitted. On the other
hand, each call to this function can be quite expensive,
so servers will not want to call 
<A HREF="kdu_serve__gen$ncrements.html">generate_increments</A> more frequently than necessary. Ideally, the function
is called only once, between changes in the client's
window of interest, but changes in the client's interests
are not generally predictable in an interactive application.
</P><P>
 If 
<B>recommended_chunk_size</B> is &gt; 0, the function will endeavour to pack messages
into chunks of the indicated size, rather than using
all bytes that can be stored in each 
<A HREF="kds_chunk.html">kds_chunk</A> object. This is especially useful for HTTP-TCP and
HTTP-UDP transports defined by JPIP, where smaller
data chunks may provide better channel state feedback
or better throughput in the face of potential packet
loss.
</P><P>
 Prior to returning, the 
<A HREF="kdu_serve.html">kdu_serve</A> object updates its internal cache model, based on
the assumption that all of the chunks will be successfully
transmitted to a client which inserts all relevant
data into its cache. In some cases, the application
may opt not to send some or all of the chunks to a
client. For example, if a remote user changes his/her
window of interest dramatically before all outstanding
chunks have been transmitted, the server application
may choose to abandon some of the chunks. This is acceptable,
so long as the application informs the 
<A HREF="kdu_serve.html">kdu_serve</A> object that it has abandoned these chunks. This may
be done by asserting 
<B>check_abandoned</B>=true in the call to 
<A HREF="kdu_serve__rel$se_chunks.html">release_chunks</A>. In this case, the application is expected to have
marked all of the chunks which were reliably transmitted
by setting their 
<B>abandoned</B> fields to false.
</P><P>
 If the application has used the 
<A HREF="kdu_serve__pus$xtra_data.html">push_extra_data</A> function to push extra data onto the internal extra
data queue (as opposed to pushing it onto the end of
a list of chunks returned by this function), the extra
data will be included in the first chunk returned by
this function, until there is no extra data left.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ReturnS">Return Value</A></H2><DIV CLASS="indented-text">
<P>
The function will NEVER return a NULL pointer. If there
is no data available, the function may return a single
chunk, which contains no data at all. This ensures
that there is always a non-empty list of data chunks
which can be passed to the 
<A HREF="kdu_serve__pus$xtra_data.html">push_extra_data</A> function, if required.
</P>
</DIV>
<H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="suggested_message_bytes">suggested_message_bytes</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
Suggested number of bytes in the messages from which
the returned chunks are composed. Each chunk is a concatenated
list of messages, each containing a header, followed
by a body, which consists of a byte range from a single
data-bin (precinct, code-stream header or metadata-bin).
As of Kakadu v6.2, the message headers are included
in the limit represented by 
<A HREF="kdu_serve__gen$ncrements.html#suggested_message_bytes">suggested_message_bytes</A> or 
<A HREF="kdu_serve__gen$ncrements.html#max_message_bytes">max_message_bytes</A>. The 
<A HREF="kdu_serve__gen$ncrements.html#suggested_message_bytes">suggested_message_bytes</A> limit is not interpreted strictly; instead, the function
tries to include whole packets from as many relevant
precinct data-bins as possible, until the suggested
limit is exceeded. It may thus be exceeded by a considerable
margin if packets are very large.
</P>
</DIV>
<H4><A NAME="max_message_bytes">max_message_bytes</A> [<B>int</B>&nbsp;&amp;]</H4><DIV CLASS="indented-text">
<P>
This argument provides a strict limit on the number
of bytes which can be included in the messages in the
returned chunk list, not including any extra data which
was pushed in via the 
<A HREF="kdu_serve__pus$xtra_data.html">push_extra_data</A> function. The limit will not be exceeded under any
conditions. This means that partial packets may be
included from the final precinct data-bin which contributes
to the chunk list. Upon return, the value of this variable
is decremented by the actual number of message bytes,
allowing the caller to keep track of the number of
bytes which can be generated in a subsequent call to
the function, unless the limit has changed. Note that
the function may return a non-NULL result, even if
the 
<A HREF="kdu_serve__gen$ncrements.html#max_message_bytes">max_message_bytes</A> argument holds 0 on entry.
</P><P>
 Prior to Kakadu v6.2, this argument provided a limit
only for the number of bytes in message bodies. This
was the most appropriate policy for implementing JPIP
as of the final Working Draft of the standard; counting
only message bodies also had a number of beneficial
attributes, such as the ability to guarantee that the
limit can be met precisely. Unfortunately, a sentence
in the description of the JPIP "len" request field
was dropped from the final text of the standard some
time ago, and this went unnoticed for several years.
As a result, Kakadu has changed to follow suit. However,
it is now possible (actually extremely likely) that
responses which are truncated to satisfy the 
<A HREF="kdu_serve__gen$ncrements.html#max_message_bytes">max_message_bytes</A> limit will fall somewhat short of the limit. To avoid
the inefficiencies created by further calls to this
function when 
<A HREF="kdu_serve__gen$ncrements.html#max_message_bytes">max_message_bytes</A> is left close to, but not exactly equal to zero, this
function sets 
<A HREF="kdu_serve__gen$ncrements.html#max_message_bytes">max_message_bytes</A> to 0 if the response which has been generated was
limited by the 
<A HREF="kdu_serve__gen$ncrements.html#max_message_bytes">max_message_bytes</A> limit.
</P>
</DIV>
<H4><A NAME="align">align</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, each message generated by this function which
crosses a precinct packet boundary will finish at a
subsequent packet boundary. The option has no effect
on messages which correspond to data-bins other than
precinct data-bins.
</P>
</DIV>
<H4><A NAME="use_extended_message_headers">use_extended_message_headers</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, each message which corresponds to a precinct
data-bin will use the extended header format, which
includes an indication of the number of complete quality
layers represented by the message together with all
bytes from the precinct which precede those in the
message.
</P>
</DIV>
<H4><A NAME="decouple_chunks">decouple_chunks</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true (this is a reasonable default), the first message
written to each chunk will have its header coded in
a manner which does not rely on successful delivery
of messages in other chunks. Specifically, in this
case the 
<A HREF="kds$coder__decouple.html">kds_id_encoder::decouple</A> function will be called prior to writing each new
chunk. For applications in which the messages are delivered
over a reliable stream oriented connection, it may
be sufficient to decouple the message header coding
less frequently, with some small efficiency savings.
In any case, the 
<A HREF="kds$coder__decouple.html">kds_id_encoder::decouple</A> function will be invoked at the start of each call
to 
<A HREF="kdu_serve__gen$ncrements.html">generate_increments</A> so that the sequences of messages generated by each
such call can be decoded independently. This is particularly
important if multiple concurrent window contexts are
used (i.e., this function is called with different
<A HREF="kdu_serve__gen$ncrements.html#context_id">context_id</A> values).
</P>
</DIV>
<H4><A NAME="context_id">context_id</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
Associates calls to this function with the relevant
window of interest, as set by the last call to 
<A HREF="kdu_serve__set_window.html">set_window</A> which had the same 
<A HREF="kdu_serve__gen$ncrements.html#context_id">context_id</A>. If there was no such call, the present function returns
NULL immediately without creating an internal window
context.
</P>
</DIV>
<H4><A NAME="suggested_chunk_size">suggested_chunk_size</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
This argument is ignored unless positive, in which
case if 
<A HREF="kdu_serve__gen$ncrements.html#suggested_chunk_size">suggested_chunk_size</A> is smaller than the 
<B>max_chunk_size</B> value passed to 
<A HREF="kdu_serve__initialize.html">initialize</A>, the internal machinery will attempt to pack JPIP
messages into smaller chunks. This can be useful, because
the best chunk size to use may depend upon channel
conditions, which vary dynamically. For example, if
data chunks are transmitted over a lossy channel (e.g.,
using UDP), the chunk size (related to packet size)
generally affects loss probability. In JPIP HTTP-TCP
or HTTP-UDP transport protocols, the chunk size determines
the granularity at which channel state information
can be obtained through chunk acknowledgements. Obviously,
then, smaller chunks may allow better channel state
estimation, particularly if the data rate is low.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu_serve__ret$ta_chunks.html"> prev </A>||<A HREF="kdu_serve__win$_finished.html"> next </A>|</P>
</BODY>
</HTML>
