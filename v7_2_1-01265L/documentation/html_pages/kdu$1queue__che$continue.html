<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_run_queue::check_continue) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$1queue__upd$ndencies.html"> prev </A>|</P>
<H1><A NAME="ToP">kdu_run_queue::check_continue</A></H1>
<P CLASS="function-text"><B>bool</B> check_continue(
<A HREF ="kdu$d_job.html">kdu_thread_job</A>&nbsp;*&nbsp;job,
<A HREF ="kdu$ntity.html">kdu_thread_entity</A>&nbsp;*&nbsp;caller)</P>
<P>[Declared in <A HREF="++++coresy$+kdu_threads+h.html">"../coresys/common/kdu_threads.h"</A>]</P><P><A HREF="kdu$1queue.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
This function embodies the key feature of the 
<A HREF="kdu$1queue.html">kdu_run_queue</A> object. The running "processor" (see introductory
comments) should call this function if it thinks that
new potential blocking conditions may have arisen on
any of the present object's sub-queues. If this turns
out to be the case, the function returns false, meaning
that the caller should return immediately so that it
stops processing. In this case, the function also sets
things up so that the supplied 
<A HREF="kdu$1queue__che$continue.html#job">job</A> will be scheduled to run as soon as the blocking conditions
are cleared; the 
<A HREF="kdu$1queue__che$continue.html#job">job</A> object is normally set up by the caller to continue
running the "processor". If the function returns true,
the running processor should continue its activities.
</P><P>
 It is worth STRESSING that if the function returns
false, it is almost certainly DANGEROUS for the caller
to do anything other than return immediately from the
running "processor" function. It should not modify
any state information that might be accessed when the
"processor" function is launched again &mdash; something
that can be very tempting to do. This is because the
next instance of the "processor" function might be
launched on a different thread, at any point after
this function returns, or even slightly before it actually
returns. It can be very tempting to record the fact
that the function returned false within some state
variable that affects the next call to the function,
but this would be a serious error. If you need to do
that, record the false return status prior to calling
this function and revoke it only after the function
returns true, thereby avoiding potential race conditions
with the next scheduled invocation of the processor
function.
</P><P>
 You should be sure that 
<A HREF="kdu$1queue__activate.html">activate</A> was called before a reference to this object was passed
to 
<A HREF="kdu$ntity__attach_queue.html">kdu_thread_entity::attach_queue</A> if you wish this function to behave in the manner
described above. Otherwise, the function will just
return true immediately, without checking anything,
because run queues that have not been activated cannot
schedule jobs.
</P><P>
 Calls to this function normally amount to nothing
other than an in-line comparison of a non-atomic internal
state variable with zero &mdash; i.e., they are extremely
cheap and can be invoked as frequently as desired without
any significant impact on processing efficiency. To
achieve this, the function assumes that all calls to
the object's 
<A HREF="kdu$1queue__upd$ndencies.html">update_dependencies</A> function that involve positive 
<B>new_dependencies</B> values are generated within the same thread as the
running processor, while other calls may arise from
different threads. This assumption is certainly correct
if the object's sub-queues are associated with 
<A HREF="kdu$3coder.html">kdu_encoder</A>, 
<A HREF="kdu$2coder.html">kdu_decoder</A>, 
<A HREF="kdu$lysis.html">kdu_analysis</A>, 
<A HREF="kdu$1hesis.html">kdu_synthesis</A>, 
<A HREF="kdu$1lysis.html">kdu_multi_analysis</A> or 
<A HREF="kdu$hesis.html">kdu_multi_synthesis</A> objects and all calls into these objects that push
or pull image data are generated by the running processor
&mdash; this is the way you are expected to use this
object. This same pattern of behaviour would most likely
be true for other processing queues that you might
implement and use with this object, because hierarchical
processing structures naturally encounter new dependencies
only due to the action the parent, while dependencies
are naturally cleared only by processing within its
descendants.
</P><P>
 In any event, this object catches positive dependency
changes and accumulates them in an internal state variable
that it expects never to be manipulated by anything
other than the running processor. Moreover, because
there is at most one running processor at any given
time, there is no need to worry about race conditions
arising in the manipulation of this internal state
variable. If there were, things would be much more
treacherous and inefficient.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="job">job</A> [<A HREF ="kdu$d_job.html">kdu_thread_job</A>&nbsp;*]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="caller">caller</A> [<A HREF ="kdu$ntity.html">kdu_thread_entity</A>&nbsp;*]</H4><DIV CLASS="indented-text">
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$1queue__upd$ndencies.html"> prev </A>|</P>
</BODY>
</HTML>
