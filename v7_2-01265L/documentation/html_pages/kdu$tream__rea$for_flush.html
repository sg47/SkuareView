<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_codestream::ready_for_flush) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$tream__trans_out.html"> prev </A>||<A HREF="kdu$tream__auto_flush.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_codestream::ready_for_flush</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_codestream.Ready_for_flush</EM></H3></DIR></DIR>
<P CLASS="function-text"><B>bool</B> ready_for_flush(
<A HREF ="kdu$d_env.html">kdu_thread_env</A>&nbsp;*&nbsp;env=NULL)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native boolean Ready_for_flush(
Kdu_thread_env&nbsp;env)</EM></P></DIR></DIR>
<P>[Declared in <A HREF="++++coresy$u_compressed+h.html">"../coresys/common/kdu_compressed.h"</A>]</P><P><A HREF="kdu$tream.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
Returns true if a call to 
<A HREF="kdu$tream__flush.html">flush</A> or 
<A HREF="kdu$tream__trans_out.html">trans_out</A> would be able to write at least one packet to the
code-stream, given the constraints imposed by image
tiling, the packet progression sequence in each relevant
tile, and the amount of compressed data which is currently
available. Both 
<A HREF="kdu$tream__flush.html">flush</A> and 
<A HREF="kdu$tream__trans_out.html">trans_out</A> effectively invoke this function (or an internal equivalent),
doing nothing (apart from returning internal state
information) if this function would return false; this
avoids the wasteful generation of empty tile-parts.
</P><P>
 From Kakadu version 7, a more efficient mechanism
for incremental flushing of the codestream is made
available through the 
<A HREF="kdu$tream__auto_flush.html">auto_flush</A> and 
<A HREF="kdu$tream__aut$trans_out.html">auto_trans_out</A> functions. These are especially beneficial in multi-threading
environments, since the point at which an incremental
flush should ideally be scheduled is hard to predict
at the application level, due to asynchronous processing
of sample data transforms and block encoding operations
within a potentially large number of threads.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="env">env</A> [<A HREF ="kdu$d_env.html">kdu_thread_env</A>&nbsp;*]</H4><DIV CLASS="indented-text">
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$tream__trans_out.html"> prev </A>||<A HREF="kdu$tream__auto_flush.html"> next </A>|</P>
</BODY>
</HTML>
