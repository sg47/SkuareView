<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (jpx_source::access_codestream) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="jpx_source__cou$ntainers.html"> prev </A>||<A HREF="jpx_source__acc$ss_layer.html"> next </A>|</P>
<H1><A NAME="ToP">jpx_source::access_codestream</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Jpx_source.Access_codestream</EM></H3></DIR></DIR>
<P CLASS="function-text"><A HREF ="jpx$ource.html">jpx_codestream_source</A> access_codestream(
<B>int</B>&nbsp;which,
<B>bool</B>&nbsp;need_main_header=true)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native Jpx_codestream_source Access_codestream(
int&nbsp;which,
boolean&nbsp;need_main_header)</EM></P></DIR></DIR>
<P>[Declared in <A HREF="++++apps+c$essed_io+jpx+h.html">"../apps/compressed_io/jpx.h"</A>]</P><P><A HREF="jpx_source.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
Provides access to the codestream identified by 
<A HREF="jpx_source__acc$destream.html#which">which</A>. If 
<A HREF="jpx_source__acc$destream.html#which">which</A> is 0, this is the first codestream in the data source;
if 
<A HREF="jpx_source__acc$destream.html#which">which</A> is 1, it is the second codestream in the data source,
and so forth.
</P><P>
 If the function is unable to access the relevant codestream
information at present, it returns an empty interface
(one whose 
<A HREF="jpx$ource__exists.html">jpx_codestream_source::exists</A> function returns false). This may happen either because
the total number of codestreams in the data source
is less than or equal to 
<A HREF="jpx_source__acc$destream.html#which">which</A>, or because the function is not yet able to parse
far enough into the data source to recover the relevant
boxes along with the code-stream's main header (if
<A HREF="jpx_source__acc$destream.html#need_main_header">need_main_header</A> is true). The latter conditions can occur only if
the underlying 
<A HREF="jp2$y_src.html">jp2_family_src</A> objct is fueled by a dynamic cache (i.e., a 
<A HREF="kdu_cache.html">kdu_cache</A> object).
</P><P>
 To be sure of eventually discovering codestreams that
exist in the original source, consider using 
<A HREF="jpx_source__gen$_metareq.html">generate_metareq</A> to augment client window requests that you send to
a JPIP server.
</P><P>
 Before this function will return a non-empty interface,
it must have encountered the contiguous codestream
(jp2c) or fragment table (ftbl) box which holds the
codestream's contents, or else it must have encountered
a multiple codestream (j2cx) box from which the presence
of the contiguous codestream or fragment table box
can be deduced.
</P><P>
 For data sources which are fueled by a dynamic cache,
the entire main header must also be available already,
unless 
<A HREF="jpx_source__acc$destream.html#need_main_header">need_main_header</A> is false, in which case the 
<A HREF="jpx$ource__stream_ready.html">jpx_codestream_source::stream_ready</A> interface can be used to determine the point at which
the main header is available. If the codestream is
represented by a fragment table box, however, it is
not possible to check for main header availability,
so the 
<A HREF="jpx_source__acc$destream.html#need_main_header">need_main_header</A> argument is ignored. The object must also have either
seen all top level box headers in the data source,
or have encountered both the JP2 header (jp2h) box
and the relevant codestream header (chdr) box.
</P><P>
 The above conditions are more stringent than those
required to count codestreams, so that 
<A HREF="jpx_source__acc$destream.html#which">which</A> may be much less than the number returned by 
<A HREF="jpx_source__cou$estreams.html">count_codestreams</A>, yet this function still returns an empty interface.
This just means that the underlying dynamic cache must
receive more data before the codestream can be accessed.
In fact, it is possible that this function succeeds
when invoked with one value for 
<A HREF="jpx_source__acc$destream.html#which">which</A> but fails when invoked with a smaller value for 
<A HREF="jpx_source__acc$destream.html#which">which</A>, because a dynamic cache might have information for
one codestream even while it is waiting to receive
information for an earlier one.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="which">which</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="need_main_header">need_main_header</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, the 
<B>kdu_codestream_source::stream_ready</B> function of any non-empty returned interface will
always return true.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="jpx_source__cou$ntainers.html"> prev </A>||<A HREF="jpx_source__acc$ss_layer.html"> next </A>|</P>
</BODY>
</HTML>
