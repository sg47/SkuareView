<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_codestream::share_buffering) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$tream__restart__2.html"> prev </A>||<A HREF="kdu$tream__destroy.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_codestream::share_buffering</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_codestream.Share_buffering</EM></H3></DIR></DIR>
<P CLASS="function-text"><B>void</B> share_buffering(
<A HREF ="kdu$tream.html">kdu_codestream</A>&nbsp;existing)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native void Share_buffering(
Kdu_codestream&nbsp;existing)</EM></P></DIR></DIR>
<P>[Declared in <A HREF="++++coresy$u_compressed+h.html">"../coresys/common/kdu_compressed.h"</A>]</P><P><A HREF="kdu$tream.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
When two or more codestream objects are to be used
simultaneously, considerable memory can be saved by
encouraging them to use the same underlying service
for buffering compressed data. This is because resources
allocated for buffering compressed data are not returned
to the system heap until the object is destroyed. By
sharing buffering resources, one code-stream may use
excess buffers already freed up by the other code-stream.
This is particularly beneficial when implementing transcoders.
The internal buffering service will not be destroyed
until all codestream objects which are sharing it have
been destroyed, so there is no need to worry about
the order in which the codestream objects are destroyed.
</P><P>
 This function is not completely thread-safe. In multi-threading
environments (see 
<A HREF="kdu$d_env.html">kdu_thread_env</A>), you should do all your buffering sharing before
you open tiles and start processing (most notably,
parallel processing in multiple threads) within the
codestreams which are going to be sharing their storage.
This is not likely to present an obstacle in practice.
</P><P>
 In multi-threaded environments, you should also make
sure that all access to codestreams which share buffering
involves the same thread group (created using 
<A HREF="kdu$ntity__create.html">kdu_thread_entity::create</A>) and supplies the optional 
<A HREF="kdu$d_env.html">kdu_thread_env</A> reference to all Kakadu functions which can accept
it.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="existing">existing</A> [<A HREF ="kdu$tream.html">kdu_codestream</A>]</H4><DIV CLASS="indented-text">
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$tream__restart__2.html"> prev </A>||<A HREF="kdu$tream__destroy.html"> next </A>|</P>
</BODY>
</HTML>
