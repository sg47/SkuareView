<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_stripe_compressor::start) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$1essor__~kd$mpressor.html"> prev </A>||<A HREF="kdu$1essor__finish.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_stripe_compressor::start</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_stripe_compressor.Start</EM></H3></DIR></DIR>
<P CLASS="function-text"><B>void</B> start(
<A HREF ="kdu$tream.html">kdu_codestream</A>&nbsp;codestream,
<B>int</B>&nbsp;num_layer_specs=0,
const&nbsp;<B>kdu_long</B>&nbsp;*&nbsp;layer_sizes=NULL,
const&nbsp;<B>kdu_uint16</B>&nbsp;*&nbsp;layer_slopes=NULL,
<B>kdu_uint16</B>&nbsp;min_slope_threshold=0,
<B>bool</B>&nbsp;no_prediction=false,
<B>bool</B>&nbsp;force_precise=false,
<B>bool</B>&nbsp;record_layer_info_in_comment=true,
<B>double</B>&nbsp;size_tolerance=0.0,
<B>int</B>&nbsp;num_components=0,
<B>bool</B>&nbsp;want_fastest=false,
<A HREF ="kdu$d_env.html">kdu_thread_env</A>&nbsp;*&nbsp;env=NULL,
<A HREF ="kdu$2queue.html">kdu_thread_queue</A>&nbsp;*&nbsp;env_queue=NULL,
<B>int</B>&nbsp;env_dbuf_height=0)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native void Start(
Kdu_codestream&nbsp;codestream,
int&nbsp;num_layer_specs,
long[]&nbsp;layer_sizes,
int[]&nbsp;layer_slopes,
int&nbsp;min_slope_threshold,
boolean&nbsp;no_prediction,
boolean&nbsp;force_precise,
boolean&nbsp;record_layer_info_in_comment,
double&nbsp;size_tolerance,
int&nbsp;num_components,
boolean&nbsp;want_fastest,
Kdu_thread_env&nbsp;env,
Kdu_thread_queue&nbsp;env_queue,
int&nbsp;env_dbuf_height)</EM></P></DIR></DIR>
<P>[Declared in <A HREF="++++apps+s$e_compressor+h.html">"../apps/support/kdu_stripe_compressor.h"</A>]</P><P><A HREF="kdu$1essor.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
Call this function to initialize the object for compression.
Each call to 
<A HREF="kdu$1essor__start.html">start</A> must be matched by a call to 
<A HREF="kdu$1essor__finish.html">finish</A>, but you may re-use the object to compress subsequent
images, if you like.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="codestream">codestream</A> [<A HREF ="kdu$tream.html">kdu_codestream</A>]</H4><DIV CLASS="indented-text">
<P>
Interface to a 
<A HREF="kdu$tream.html">kdu_codestream</A> object whose 
<B>create</B> function has already been called. The 
<A HREF="kdu_params__fin$lize_all__1.html">kdu_params::finalize_all</A> function should not be called by the application;
it will be invoked from within the present function,
possibly after making some final adjustments to coding
parameter attributes which have not been configured
by the application.
</P>
</DIV>
<H4><A NAME="num_layer_specs">num_layer_specs</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
If this argument is equal to 0, the number of quality
layers to build into the code-stream is recovered from
the 
<A HREF="globals.html#Clayers">Clayers</A> coding parameter attribute, which the application
may have been configured prior to calling this function.
If the 
<A HREF="globals.html#Clayers">Clayers</A> attribute was not set, it will default to 1 when the
<A HREF="kdu_params__fin$lize_all__1.html">kdu_params::finalize_all</A> function is called from within this function. If the
present argument is greater than 0, and the 
<A HREF="globals.html#Clayers">Clayers</A> attribute has not already been set, it will be set
equal to the value of 
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A>. Regardless of the final number of code-stream quality
layers which are used, the 
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A> argument provides the number of entries in the 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> and 
<A HREF="kdu$1essor__start.html#layer_slopes">layer_slopes</A> arrays, if non-NULL. These arrays, if provided, allow
the application to specify the properties of the quality
layers. If no layer sizes or slopes are specified,
a logarithmically spaced set of quality layers will
be constructed, following the conventions described
with the 
<A HREF="kdu$tream__flush.html">kdu_codestream::flush</A> function.
</P>
</DIV>
<H4><A NAME="layer_sizes">layer_sizes</A> [const&nbsp;<B>kdu_long</B>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
If non-NULL, this argument points to an array with
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A> entries, containing the cumulative number of bytes
from the start of the code-stream to the end of each
quality layer, if the code-stream were to be arranged
in layer progressive order. The code-stream may be
arranged in a very different order, of course, but
that has no impact on the sizes of the layers, as controlled
by this argument. If the actual number of quality layers,
as specified by the 
<A HREF="globals.html#Clayers">Clayers</A> attribute, is smaller than 
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A>, not all of the entries in this array will be used.
If the actual number of quality layers is larger than
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A>, the additional quality layers will be empty. This
argument is ignored if 
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A> is 0.
</P>
</DIV>
<H4><A NAME="layer_slopes">layer_slopes</A> [const&nbsp;<B>kdu_uint16</B>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
If non-NULL, this argument points to an array with
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A> entries, containing the distortion-length slope thresholds
associated with each quality layer. This argument is
ignored if 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> is non-NULL, or 
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A> is 0. For an explanation of the logarithmic representation
used for distortion length slope thresholds in Kakadu,
see the comments associated with the 
<A HREF="kdu$tream__flush.html">kdu_codestream::flush</A> function.
</P>
</DIV>
<H4><A NAME="min_slope_threshold">min_slope_threshold</A> [<B>kdu_uint16</B>]</H4><DIV CLASS="indented-text">
<P>
If this argument is non-zero, the 
<A HREF="kdu$tream__set$1threshold.html">kdu_codestream::set_min_slope_threshold</A> function will be used to apply this slope threshold
prior to compression. As explained in connection with
that function, this can help to speed up the compression
process significantly. Although the application could
invoke 
<A HREF="kdu$tream__set$1threshold.html">kdu_codestream::set_min_slope_threshold</A> itself, providing a non-zero argument here will prevent
the present function from calling 
<A HREF="kdu$tream__set$max_bytes.html">kdu_codestream::set_max_bytes</A> if the 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> array is non-NULL. More precisely, the function follows
the following set of rules in determining what speedup
features to apply:
</P><UL><LI>
If 
<A HREF="kdu$1essor__start.html#no_prediction">no_prediction</A> is true, no speedup features will be applied;
</LI><LI>
else, if 
<A HREF="kdu$1essor__start.html#min_slope_threshold">min_slope_threshold</A> is non-zero, the value will be supplied to 
<A HREF="kdu$tream__set$1threshold.html">kdu_codestream::set_min_slope_threshold</A>;
</LI><LI>
else, if 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> is non-NULL, the last entry in the 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> array will be passed to 
<A HREF="kdu$tream__set$max_bytes.html">kdu_codestream::set_max_bytes</A>;
</LI><LI>
else, if 
<A HREF="kdu$1essor__start.html#layer_slopes">layer_slopes</A> is non-NULL, the last entry in the 
<A HREF="kdu$1essor__start.html#layer_slopes">layer_slopes</A> array will be passed to 
<A HREF="kdu$tream__set$1threshold.html">kdu_codestream::set_min_slope_threshold</A>.
</LI></UL>
</DIV>
<H4><A NAME="no_prediction">no_prediction</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, neither the 
<A HREF="kdu$tream__set$max_bytes.html">kdu_codestream::set_max_bytes</A> function, nor the 
<A HREF="kdu$tream__set$1threshold.html">kdu_codestream::set_min_slope_threshold</A> function will be invoked. Applications should set
this argument to true only if they want to adopt a
very conservative stance in relation to maximizing
image quality at the expense of compression speed.
For typical images, Kakadu's code-block truncation
prediction mechanisms have no impact on image quality
at all, while saving processing time.
</P>
</DIV>
<H4><A NAME="force_precise">force_precise</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, 32-bit internal representations are used by
the compression engines created by this object, regardless
of the precision of the image samples reported by 
<A HREF="kdu$tream__get$bit_depth.html">kdu_codestream::get_bit_depth</A>.
</P>
</DIV>
<H4><A NAME="record_layer_info_in_comment">record_layer_info_in_comment</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, the rate-distortion slope and the target number
of bytes associated with each quality layer will be
recorded in a COM (comment) marker segment in the main
code-stream header. This can be very useful for applications
which wish to process the code-stream later in a manner
which depends upon the interpretation of the quality
layers. For this reason, you should generally set this
argument to true, unless you want to get the smallest
possible file size when compressing small images. For
more information on this option, consult the comments
appearing with its namesake in 
<A HREF="kdu$tream__flush.html">kdu_codestream::flush</A>.
</P>
</DIV>
<H4><A NAME="size_tolerance">size_tolerance</A> [<B>double</B>]</H4><DIV CLASS="indented-text">
<P>
This argument is ignored unless layering is controlled
by cumulative layer sizes supplied via a 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> array. In this case, it may be used to trade accuracy
for speed when determining the distortion-length slopes
which achieve the target layer sizes as closely as
possible. In particular, the algorithm will finish
once it has found a distortion-length slope which yields
a size in the range target*(1-tolerance) &lt;= size
&lt;= target, where target is the target size for the
relevant layer. If no such slope can be found, the
layer is assigned a slope such that the size is as
close as possible to the target, without exceeding
it.
</P>
</DIV>
<H4><A NAME="num_components">num_components</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
If zero, the number of image components to be supplied
to the 
<A HREF="kdu$1essor__push_stripe__1.html">push_stripe</A> function is identical to the value returned by 
<A HREF="kdu$tream__get$omponents.html">kdu_codestream::get_num_components</A>, with its optional 
<B>want_output_comps</B> argument set to true. However, you may supply a smaller
number of image components during compression, if you
think that these provide sufficient information to
generate all codestream image components. This can
happen where a Part 2 multi-component transformation
defines more MCT output components than there are codestream
image components. Then, during compression, it may
be possible to invert the defined multi-component transform
network by supplying only a subset of the MCT output
components as source components (the components supplied
to 
<A HREF="kdu$1essor__push_stripe__1.html">push_stripe</A>). If a non-zero 
<A HREF="kdu$1essor__start.html#num_components">num_components</A> argument is supplied, this is the number of components
you will push to 
<A HREF="kdu$1essor__push_stripe__1.html">push_stripe</A> &mdash; if there are not sufficient components, the
machinery will generate an appropriate error message
through 
<A HREF="kdu_error.html">kdu_error</A>. For more on this, consult the description of the
<A HREF="kdu$1lysis.html">kdu_multi_analysis</A> object on which this is built.
</P>
</DIV>
<H4><A NAME="want_fastest">want_fastest</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If this argument is true and 
<A HREF="kdu$1essor__start.html#force_precise">force_precise</A> is false, the function selects a 16-bit internal representation
(usually leads to the fastest processing) even if this
will result in reduced image quality, at least for
irreversible processing. For image components which
require reversible compression, the 32-bit representation
must be selected if the image sample precision is too
high, or else numerical overflow might occur.
</P>
</DIV>
<H4><A NAME="env">env</A> [<A HREF ="kdu$d_env.html">kdu_thread_env</A>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
This argument is used to establish multi-threaded processing.
For a discussion of the multi-threaded processing features
offered by the present object, see the introductory
comments to 
<A HREF="kdu$1essor.html">kdu_stripe_compressor</A>. We remind you here, however, that all calls to 
<A HREF="kdu$1essor__start.html">start</A>, 
<B>process</B> and 
<A HREF="kdu$1essor__finish.html">finish</A> must be executed from the same thread, which is identified
only in this function. If you re-use the object to
process a subsequent image, you may change threads
between the two uses, passing the appropriate appropriate
<A HREF="kdu$d_env.html">kdu_thread_env</A> reference in each call to 
<A HREF="kdu$1essor__start.html">start</A>. For the single-threaded processing model used prior
to Kakadu version 5.1, set this argument to NULL.
</P>
</DIV>
<H4><A NAME="env_queue">env_queue</A> [<A HREF ="kdu$2queue.html">kdu_thread_queue</A>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
This argument is ignored unless 
<A HREF="kdu$1essor__start.html#env">env</A> is non-NULL, in which case a non-NULL 
<A HREF="kdu$1essor__start.html#env_queue">env_queue</A> means that all multi-threaded processing queues created
inside the present object, by calls to 
<B>process</B>, should be created as sub-queues of the identified
<A HREF="kdu$1essor__start.html#env_queue">env_queue</A>.
</P><P>
 Note that 
<A HREF="kdu$1essor__start.html#env_queue">env_queue</A> is not detached from the multi-threaded environment
(identified by 
<A HREF="kdu$1essor__start.html#env">env</A>) when the current object is destroyed, or by 
<A HREF="kdu$1essor__finish.html">finish</A>. It is, therefore, possible to have other 
<A HREF="kdu$1essor.html">kdu_stripe_compressor</A> objects (or indeed any other processing machinery)
share this 
<A HREF="kdu$1essor__start.html#env_queue">env_queue</A>.
</P>
</DIV>
<H4><A NAME="env_dbuf_height">env_dbuf_height</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
This argument may be used to introduce and control
parallelism in the DWT processing steps, allowing you
to distribute the load associated with multiple tile-components
across multiple threads. In the simplest case, this
argument is 0, and parallel processing applies only
to the block encoding processes. For a small number
of processors, this is usually sufficient to keep all
CPU's active. If this argument is non-zero, however,
the 
<A HREF="kdu$1lysis.html">kdu_multi_analysis</A> objects on which all processing is based, are created
with 
<B>double_buffering</B> equal to true and a 
<B>processing_stripe_height</B> equal to the value supplied for this argument. See
<A HREF="kdu$1lysis__create__1.html">kdu_multi_analysis::create</A> for a more comprehensive discussion of double buffering
principles and guidelines.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$1essor__~kd$mpressor.html"> prev </A>||<A HREF="kdu$1essor__finish.html"> next </A>|</P>
</BODY>
</HTML>
